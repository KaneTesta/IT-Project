/*!
* Customized version of iScroll.js 0.0.2
* It fixes bugs affecting its integration with fullpage.js
*/
/*! iScroll v5.2.0 ~ (c) 2008-2016 Matteo Spinelli ~ http://cubiq.org/license */
!(function (t, i, e) {
	function s(e, s) {
		this.wrapper = typeof e === 'string' ? i.querySelector(e) : e, this.scroller = this.wrapper.children[0], this.scrollerStyle = this.scroller.style, this.options = {
			resizeScrollbars: !0, mouseWheelSpeed: 20, snapThreshold: 0.334, disablePointer: !h.hasPointer, disableTouch: h.hasPointer || !h.hasTouch, disableMouse: h.hasPointer || h.hasTouch, startX: 0, startY: 0, scrollY: !0, directionLockThreshold: 5, momentum: !0, bounce: !0, bounceTime: 600, bounceEasing: '', preventDefault: !0, preventDefaultException: { tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|LABEL)$/ }, HWCompositing: !0, useTransition: !0, useTransform: !0, bindToWrapper: typeof t.onmousedown === 'undefined',
		}; for (const o in s) this.options[o] = s[o]; this.translateZ = this.options.HWCompositing && h.hasPerspective ? ' translateZ(0)' : '', this.options.useTransition = h.hasTransition && this.options.useTransition, this.options.useTransform = h.hasTransform && this.options.useTransform, this.options.eventPassthrough = this.options.eventPassthrough === !0 ? 'vertical' : this.options.eventPassthrough, this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault, this.options.scrollY = this.options.eventPassthrough != 'vertical' && this.options.scrollY, this.options.scrollX = this.options.eventPassthrough != 'horizontal' && this.options.scrollX, this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough, this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold, this.options.bounceEasing = typeof this.options.bounceEasing === 'string' ? h.ease[this.options.bounceEasing] || h.ease.circular : this.options.bounceEasing, this.options.resizePolling = void 0 === this.options.resizePolling ? 60 : this.options.resizePolling, this.options.tap === !0 && (this.options.tap = 'tap'), this.options.useTransition || this.options.useTransform || /relative|absolute/i.test(this.scrollerStyle.position) || (this.scrollerStyle.position = 'relative'), this.options.shrinkScrollbars == 'scale' && (this.options.useTransition = !1), this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1, this.x = 0, this.y = 0, this.directionX = 0, this.directionY = 0, this._events = {}, this._init(), this.refresh(), this.scrollTo(this.options.startX, this.options.startY), this.enable();
	} function o(t, e, s) { const o = i.createElement('div'); const n = i.createElement('div'); return s === !0 && (o.style.cssText = 'position:absolute;z-index:9999', n.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px'), n.className = 'iScrollIndicator', t == 'h' ? (s === !0 && (o.style.cssText += ';height:7px;left:2px;right:2px;bottom:0', n.style.height = '100%'), o.className = 'iScrollHorizontalScrollbar') : (s === !0 && (o.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px', n.style.width = '100%'), o.className = 'iScrollVerticalScrollbar'), o.style.cssText += ';overflow:hidden', e || (o.style.pointerEvents = 'none'), o.appendChild(n), o; } function n(e, s) {
		this.wrapper = typeof s.el === 'string' ? i.querySelector(s.el) : s.el, this.wrapperStyle = this.wrapper.style, this.indicator = this.wrapper.children[0], this.indicatorStyle = this.indicator.style, this.scroller = e, this.options = {
			listenX: !0, listenY: !0, interactive: !1, resize: !0, defaultScrollbars: !1, shrink: !1, fade: !1, speedRatioX: 0, speedRatioY: 0,
		}; for (const o in s) this.options[o] = s[o]; if (this.sizeRatioX = 1, this.sizeRatioY = 1, this.maxPosX = 0, this.maxPosY = 0, this.options.interactive && (this.options.disableTouch || (h.addEvent(this.indicator, 'touchstart', this), h.addEvent(t, 'touchend', this)), this.options.disablePointer || (h.addEvent(this.indicator, h.prefixPointerEvent('pointerdown'), this), h.addEvent(t, h.prefixPointerEvent('pointerup'), this)), this.options.disableMouse || (h.addEvent(this.indicator, 'mousedown', this), h.addEvent(t, 'mouseup', this))), this.options.fade) { this.wrapperStyle[h.style.transform] = this.scroller.translateZ; const n = h.style.transitionDuration; if (!n) return; this.wrapperStyle[n] = h.isBadAndroid ? '0.0001ms' : '0ms'; const a = this; h.isBadAndroid && r(() => { a.wrapperStyle[n] === '0.0001ms' && (a.wrapperStyle[n] = '0s'); }), this.wrapperStyle.opacity = '0'; }
	} var r = t.requestAnimationFrame || t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || t.oRequestAnimationFrame || t.msRequestAnimationFrame || function (i) { t.setTimeout(i, 1e3 / 60); }; var h = (function () {
		function s(t) { return r !== !1 && (r === '' ? t : r + t.charAt(0).toUpperCase() + t.substr(1)); } const o = {}; const n = i.createElement('div').style; var r = (function () { for (var t, i = ['t', 'webkitT', 'MozT', 'msT', 'OT'], e = 0, s = i.length; e < s; e++) if (t = `${i[e]}ransform`, t in n) return i[e].substr(0, i[e].length - 1); return !1; }()); o.getTime = Date.now || function () { return (new Date()).getTime(); }, o.extend = function (t, i) { for (const e in i)t[e] = i[e]; }, o.addEvent = function (t, i, e, s) { t.addEventListener(i, e, !!s); }, o.removeEvent = function (t, i, e, s) { t.removeEventListener(i, e, !!s); }, o.prefixPointerEvent = function (i) { return t.MSPointerEvent ? `MSPointer${i.charAt(7).toUpperCase()}${i.substr(8)}` : i; }, o.momentum = function (t, i, s, o, n, r) { let h; let a; let l = t - i; const c = e.abs(l) / s; return r = void 0 === r ? 6e-4 : r, h = t + c * c / (2 * r) * (l < 0 ? -1 : 1), a = c / r, h < o ? (h = n ? o - n / 2.5 * (c / 8) : o, l = e.abs(h - t), a = l / c) : h > 0 && (h = n ? n / 2.5 * (c / 8) : 0, l = e.abs(t) + h, a = l / c), { destination: e.round(h), duration: a }; }; const h = s('transform'); return o.extend(o, {
			hasTransform: h !== !1, hasPerspective: s('perspective') in n, hasTouch: 'ontouchstart' in t, hasPointer: !(!t.PointerEvent && !t.MSPointerEvent), hasTransition: s('transition') in n,
		}), o.isBadAndroid = (function () { const i = t.navigator.appVersion; if (/Android/.test(i) && !/Chrome\/\d/.test(i)) { const e = i.match(/Safari\/(\d+.\d)/); return !(e && typeof e === 'object' && e.length >= 2) || parseFloat(e[1]) < 535.19; } return !1; }()), o.extend(o.style = {}, {
			transform: h, transitionTimingFunction: s('transitionTimingFunction'), transitionDuration: s('transitionDuration'), transitionDelay: s('transitionDelay'), transformOrigin: s('transformOrigin'),
		}), o.hasClass = function (t, i) { const e = new RegExp(`(^|\\s)${i}(\\s|$)`); return e.test(t.className); }, o.addClass = function (t, i) { if (!o.hasClass(t, i)) { const e = t.className.split(' '); e.push(i), t.className = e.join(' '); } }, o.removeClass = function (t, i) { if (o.hasClass(t, i)) { const e = new RegExp(`(^|\\s)${i}(\\s|$)`, 'g'); t.className = t.className.replace(e, ' '); } }, o.offset = function (t) { for (var i = -t.offsetLeft, e = -t.offsetTop; t = t.offsetParent;)i -= t.offsetLeft, e -= t.offsetTop; return { left: i, top: e }; }, o.preventDefaultException = function (t, i) { for (const e in i) if (i[e].test(t[e])) return !0; return !1; }, o.extend(o.eventType = {}, {
			touchstart: 1, touchmove: 1, touchend: 1, mousedown: 2, mousemove: 2, mouseup: 2, pointerdown: 3, pointermove: 3, pointerup: 3, MSPointerDown: 3, MSPointerMove: 3, MSPointerUp: 3,
		}), o.extend(o.ease = {}, {
			quadratic: { style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', fn(t) { return t * (2 - t); } }, circular: { style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', fn(t) { return e.sqrt(1 - --t * t); } }, back: { style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)', fn(t) { const i = 4; return (t -= 1) * t * ((i + 1) * t + i) + 1; } }, bounce: { style: '', fn(t) { return (t /= 1) < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; } }, elastic: { style: '', fn(t) { const i = 0.22; const s = 0.4; return t === 0 ? 0 : t == 1 ? 1 : s * e.pow(2, -10 * t) * e.sin((t - i / 4) * (2 * e.PI) / i) + 1; } },
		}), o.tap = function (t, e) { const s = i.createEvent('Event'); s.initEvent(e, !0, !0), s.pageX = t.pageX, s.pageY = t.pageY, t.target.dispatchEvent(s); }, o.click = function (e) { let s; const o = e.target; /(SELECT|INPUT|TEXTAREA)/i.test(o.tagName) || (s = i.createEvent(t.MouseEvent ? 'MouseEvents' : 'Event'), s.initEvent('click', !0, !0), s.view = e.view || t, s.detail = 1, s.screenX = o.screenX || 0, s.screenY = o.screenY || 0, s.clientX = o.clientX || 0, s.clientY = o.clientY || 0, s.ctrlKey = !!e.ctrlKey, s.altKey = !!e.altKey, s.shiftKey = !!e.shiftKey, s.metaKey = !!e.metaKey, s.button = 0, s.relatedTarget = null, s._constructed = !0, o.dispatchEvent(s)); }, o;
	}()); s.prototype = {
		version: '5.2.0',
		_init() { this._initEvents(), (this.options.scrollbars || this.options.indicators) && this._initIndicators(), this.options.mouseWheel && this._initWheel(), this.options.snap && this._initSnap(), this.options.keyBindings && this._initKeys(); },
		destroy() { this._initEvents(!0), clearTimeout(this.resizeTimeout), this.resizeTimeout = null, this._execEvent('destroy'); },
		_transitionEnd(t) { t.target == this.scroller && this.isInTransition && (this._transitionTime(), this.resetPosition(this.options.bounceTime) || (this.isInTransition = !1, this._execEvent('scrollEnd'))); },
		_start(t) { if (h.eventType[t.type] != 1) { let i; if (i = t.which ? t.button : t.button < 2 ? 0 : t.button == 4 ? 1 : 2, i !== 0) return; } if (this.enabled && (!this.initiated || h.eventType[t.type] === this.initiated)) { !this.options.preventDefault || h.isBadAndroid || h.preventDefaultException(t.target, this.options.preventDefaultException) || t.preventDefault(); let s; const o = t.touches ? t.touches[0] : t; this.initiated = h.eventType[t.type], this.moved = !1, this.distX = 0, this.distY = 0, this.directionX = 0, this.directionY = 0, this.directionLocked = 0, this.startTime = h.getTime(), this.options.useTransition && this.isInTransition ? (this._transitionTime(), this.isInTransition = !1, s = this.getComputedPosition(), this._translate(e.round(s.x), e.round(s.y)), this._execEvent('scrollEnd')) : !this.options.useTransition && this.isAnimating && (this.isAnimating = !1, this._execEvent('scrollEnd')), this.startX = this.x, this.startY = this.y, this.absStartX = this.x, this.absStartY = this.y, this.pointX = o.pageX, this.pointY = o.pageY, this._execEvent('beforeScrollStart'); } },
		_move(t) { if (this.enabled && h.eventType[t.type] === this.initiated) { this.options.preventDefault && t.preventDefault(); let i; let s; let o; let n; const r = t.touches ? t.touches[0] : t; let a = r.pageX - this.pointX; let l = r.pageY - this.pointY; const c = h.getTime(); if (this.pointX = r.pageX, this.pointY = r.pageY, this.distX += a, this.distY += l, o = e.abs(this.distX), n = e.abs(this.distY), !(c - this.endTime > 300 && o < 10 && n < 10)) { if (this.directionLocked || this.options.freeScroll || (o > n + this.options.directionLockThreshold ? this.directionLocked = 'h' : n >= o + this.options.directionLockThreshold ? this.directionLocked = 'v' : this.directionLocked = 'n'), this.directionLocked == 'h') { if (this.options.eventPassthrough == 'vertical')t.preventDefault(); else if (this.options.eventPassthrough == 'horizontal') return void (this.initiated = !1); l = 0; } else if (this.directionLocked == 'v') { if (this.options.eventPassthrough == 'horizontal')t.preventDefault(); else if (this.options.eventPassthrough == 'vertical') return void (this.initiated = !1); a = 0; }a = this.hasHorizontalScroll ? a : 0, l = this.hasVerticalScroll ? l : 0, i = this.x + a, s = this.y + l, (i > 0 || i < this.maxScrollX) && (i = this.options.bounce ? this.x + a / 3 : i > 0 ? 0 : this.maxScrollX), (s > 0 || s < this.maxScrollY) && (s = this.options.bounce ? this.y + l / 3 : s > 0 ? 0 : this.maxScrollY), this.directionX = a > 0 ? -1 : a < 0 ? 1 : 0, this.directionY = l > 0 ? -1 : l < 0 ? 1 : 0, this.moved || this._execEvent('scrollStart'), this.moved = !0, this._translate(i, s), c - this.startTime > 300 && (this.startTime = c, this.startX = this.x, this.startY = this.y); } } },
		_end(t) { if (this.enabled && h.eventType[t.type] === this.initiated) { this.options.preventDefault && !h.preventDefaultException(t.target, this.options.preventDefaultException) && t.preventDefault(); let i; let s; const o = (t.changedTouches ? t.changedTouches[0] : t, h.getTime() - this.startTime); let n = e.round(this.x); let r = e.round(this.y); const a = e.abs(n - this.startX); const l = e.abs(r - this.startY); let c = 0; let p = ''; if (this.isInTransition = 0, this.initiated = 0, this.endTime = h.getTime(), !this.resetPosition(this.options.bounceTime)) { if (this.scrollTo(n, r), !this.moved) return this.options.tap && h.tap(t, this.options.tap), this.options.click && h.click(t), void this._execEvent('scrollCancel'); if (this._events.flick && o < 200 && a < 100 && l < 100) return void this._execEvent('flick'); if (this.options.momentum && o < 300 && (i = this.hasHorizontalScroll ? h.momentum(this.x, this.startX, o, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : { destination: n, duration: 0 }, s = this.hasVerticalScroll ? h.momentum(this.y, this.startY, o, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : { destination: r, duration: 0 }, n = i.destination, r = s.destination, c = e.max(i.duration, s.duration), this.isInTransition = 1), this.options.snap) { const d = this._nearestSnap(n, r); this.currentPage = d, c = this.options.snapSpeed || e.max(e.max(e.min(e.abs(n - d.x), 1e3), e.min(e.abs(r - d.y), 1e3)), 300), n = d.x, r = d.y, this.directionX = 0, this.directionY = 0, p = this.options.bounceEasing; } return n != this.x || r != this.y ? ((n > 0 || n < this.maxScrollX || r > 0 || r < this.maxScrollY) && (p = h.ease.quadratic), void this.scrollTo(n, r, c, p)) : void this._execEvent('scrollEnd'); } } },
		_resize() { const t = this; clearTimeout(this.resizeTimeout), this.resizeTimeout = setTimeout(() => { t.refresh(); }, this.options.resizePolling); },
		resetPosition(t) { let i = this.x; let e = this.y; return t = t || 0, !this.hasHorizontalScroll || this.x > 0 ? i = 0 : this.x < this.maxScrollX && (i = this.maxScrollX), !this.hasVerticalScroll || this.y > 0 ? e = 0 : this.y < this.maxScrollY && (e = this.maxScrollY), (i != this.x || e != this.y) && (this.scrollTo(i, e, t, this.options.bounceEasing), !0); },
		disable() { this.enabled = !1; },
		enable() { this.enabled = !0; },
		refresh() { this.wrapper.offsetHeight; this.wrapperWidth = this.wrapper.clientWidth, this.wrapperHeight = this.wrapper.clientHeight, this.scrollerWidth = this.scroller.offsetWidth, this.scrollerHeight = this.scroller.offsetHeight, this.maxScrollX = this.wrapperWidth - this.scrollerWidth, this.maxScrollY = this.wrapperHeight - this.scrollerHeight, this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0, this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0, this.hasHorizontalScroll || (this.maxScrollX = 0, this.scrollerWidth = this.wrapperWidth), this.hasVerticalScroll || (this.maxScrollY = 0, this.scrollerHeight = this.wrapperHeight), this.endTime = 0, this.directionX = 0, this.directionY = 0, this.wrapperOffset = h.offset(this.wrapper), this._execEvent('refresh'), this.resetPosition(); },
		on(t, i) { this._events[t] || (this._events[t] = []), this._events[t].push(i); },
		off(t, i) { if (this._events[t]) { const e = this._events[t].indexOf(i); e > -1 && this._events[t].splice(e, 1); } },
		_execEvent(t) { if (this._events[t]) { let i = 0; const e = this._events[t].length; if (e) for (;i < e; i++) this._events[t][i].apply(this, [].slice.call(arguments, 1)); } },
		scrollBy(t, i, e, s) { t = this.x + t, i = this.y + i, e = e || 0, this.scrollTo(t, i, e, s); },
		scrollTo(t, i, e, s) { s = s || h.ease.circular, this.isInTransition = this.options.useTransition && e > 0; const o = this.options.useTransition && s.style; !e || o ? (o && (this._transitionTimingFunction(s.style), this._transitionTime(e)), this._translate(t, i)) : this._animate(t, i, e, s.fn); },
		scrollToElement(t, i, s, o, n) { if (t = t.nodeType ? t : this.scroller.querySelector(t)) { const r = h.offset(t); r.left -= this.wrapperOffset.left, r.top -= this.wrapperOffset.top, s === !0 && (s = e.round(t.offsetWidth / 2 - this.wrapper.offsetWidth / 2)), o === !0 && (o = e.round(t.offsetHeight / 2 - this.wrapper.offsetHeight / 2)), r.left -= s || 0, r.top -= o || 0, r.left = r.left > 0 ? 0 : r.left < this.maxScrollX ? this.maxScrollX : r.left, r.top = r.top > 0 ? 0 : r.top < this.maxScrollY ? this.maxScrollY : r.top, i = void 0 === i || i === null || i === 'auto' ? e.max(e.abs(this.x - r.left), e.abs(this.y - r.top)) : i, this.scrollTo(r.left, r.top, i, n); } },
		_transitionTime(t) { if (this.options.useTransition) { t = t || 0; const i = h.style.transitionDuration; if (i) { if (this.scrollerStyle[i] = `${t}ms`, !t && h.isBadAndroid) { this.scrollerStyle[i] = '0.0001ms'; const e = this; r(() => { e.scrollerStyle[i] === '0.0001ms' && (e.scrollerStyle[i] = '0s'); }); } if (this.indicators) for (let s = this.indicators.length; s--;) this.indicators[s].transitionTime(t); } } },
		_transitionTimingFunction(t) { if (this.scrollerStyle[h.style.transitionTimingFunction] = t, this.indicators) for (let i = this.indicators.length; i--;) this.indicators[i].transitionTimingFunction(t); },
		_translate(t, i) { if (this.options.useTransform ? this.scrollerStyle[h.style.transform] = `translate(${t}px,${i}px)${this.translateZ}` : (t = e.round(t), i = e.round(i), this.scrollerStyle.left = `${t}px`, this.scrollerStyle.top = `${i}px`), this.x = t, this.y = i, this.indicators) for (let s = this.indicators.length; s--;) this.indicators[s].updatePosition(); },
		_initEvents(i) { const e = i ? h.removeEvent : h.addEvent; const s = this.options.bindToWrapper ? this.wrapper : t; e(t, 'orientationchange', this), e(t, 'resize', this), this.options.click && e(this.wrapper, 'click', this, !0), this.options.disableMouse || (e(this.wrapper, 'mousedown', this), e(s, 'mousemove', this), e(s, 'mousecancel', this), e(s, 'mouseup', this)), h.hasPointer && !this.options.disablePointer && (e(this.wrapper, h.prefixPointerEvent('pointerdown'), this), e(s, h.prefixPointerEvent('pointermove'), this), e(s, h.prefixPointerEvent('pointercancel'), this), e(s, h.prefixPointerEvent('pointerup'), this)), h.hasTouch && !this.options.disableTouch && (e(this.wrapper, 'touchstart', this), e(s, 'touchmove', this), e(s, 'touchcancel', this), e(s, 'touchend', this)), e(this.scroller, 'transitionend', this), e(this.scroller, 'webkitTransitionEnd', this), e(this.scroller, 'oTransitionEnd', this), e(this.scroller, 'MSTransitionEnd', this); },
		getComputedPosition() { let i; let e; let s = t.getComputedStyle(this.scroller, null); return this.options.useTransform ? (s = s[h.style.transform].split(')')[0].split(', '), i = +(s[12] || s[4]), e = +(s[13] || s[5])) : (i = +s.left.replace(/[^-\d.]/g, ''), e = +s.top.replace(/[^-\d.]/g, '')), { x: i, y: e }; },
		_initIndicators() {
			function t(t) { if (h.indicators) for (let i = h.indicators.length; i--;)t.call(h.indicators[i]); } let i; const e = this.options.interactiveScrollbars; const s = typeof this.options.scrollbars !== 'string'; let r = []; var h = this; this.indicators = [], this.options.scrollbars && (this.options.scrollY && (i = {
				el: o('v', e, this.options.scrollbars), interactive: e, defaultScrollbars: !0, customStyle: s, resize: this.options.resizeScrollbars, shrink: this.options.shrinkScrollbars, fade: this.options.fadeScrollbars, listenX: !1,
			}, this.wrapper.appendChild(i.el), r.push(i)), this.options.scrollX && (i = {
				el: o('h', e, this.options.scrollbars), interactive: e, defaultScrollbars: !0, customStyle: s, resize: this.options.resizeScrollbars, shrink: this.options.shrinkScrollbars, fade: this.options.fadeScrollbars, listenY: !1,
			}, this.wrapper.appendChild(i.el), r.push(i))), this.options.indicators && (r = r.concat(this.options.indicators)); for (let a = r.length; a--;) this.indicators.push(new n(this, r[a])); this.options.fadeScrollbars && (this.on('scrollEnd', () => { t(function () { this.fade(); }); }), this.on('scrollCancel', () => { t(function () { this.fade(); }); }), this.on('scrollStart', () => { t(function () { this.fade(1); }); }), this.on('beforeScrollStart', () => { t(function () { this.fade(1, !0); }); })), this.on('refresh', () => { t(function () { this.refresh(); }); }), this.on('destroy', function () { t(function () { this.destroy(); }), delete this.indicators; });
		},
		_initWheel() { h.addEvent(this.wrapper, 'wheel', this), h.addEvent(this.wrapper, 'mousewheel', this), h.addEvent(this.wrapper, 'DOMMouseScroll', this), this.on('destroy', function () { clearTimeout(this.wheelTimeout), this.wheelTimeout = null, h.removeEvent(this.wrapper, 'wheel', this), h.removeEvent(this.wrapper, 'mousewheel', this), h.removeEvent(this.wrapper, 'DOMMouseScroll', this); }); },
		_wheel(t) { if (this.enabled) { let i; let s; let o; let n; const r = this; if (void 0 === this.wheelTimeout && r._execEvent('scrollStart'), clearTimeout(this.wheelTimeout), this.wheelTimeout = setTimeout(() => { r.options.snap || r._execEvent('scrollEnd'), r.wheelTimeout = void 0; }, 400), 'deltaX' in t)t.deltaMode === 1 ? (i = -t.deltaX * this.options.mouseWheelSpeed, s = -t.deltaY * this.options.mouseWheelSpeed) : (i = -t.deltaX, s = -t.deltaY); else if ('wheelDeltaX' in t)i = t.wheelDeltaX / 120 * this.options.mouseWheelSpeed, s = t.wheelDeltaY / 120 * this.options.mouseWheelSpeed; else if ('wheelDelta' in t)i = s = t.wheelDelta / 120 * this.options.mouseWheelSpeed; else { if (!('detail' in t)) return; i = s = -t.detail / 3 * this.options.mouseWheelSpeed; } if (i *= this.options.invertWheelDirection, s *= this.options.invertWheelDirection, this.hasVerticalScroll || (i = s, s = 0), this.options.snap) return o = this.currentPage.pageX, n = this.currentPage.pageY, i > 0 ? o-- : i < 0 && o++, s > 0 ? n-- : s < 0 && n++, void this.goToPage(o, n); o = this.x + e.round(this.hasHorizontalScroll ? i : 0), n = this.y + e.round(this.hasVerticalScroll ? s : 0), this.directionX = i > 0 ? -1 : i < 0 ? 1 : 0, this.directionY = s > 0 ? -1 : s < 0 ? 1 : 0, o > 0 ? o = 0 : o < this.maxScrollX && (o = this.maxScrollX), n > 0 ? n = 0 : n < this.maxScrollY && (n = this.maxScrollY), this.scrollTo(o, n, 0); } },
		_initSnap() {
			this.currentPage = {}, typeof this.options.snap === 'string' && (this.options.snap = this.scroller.querySelectorAll(this.options.snap)), this.on('refresh', function () {
				let t; let i; let s; let o; let n; let r; let h = 0; let a = 0; let l = 0; const c = this.options.snapStepX || this.wrapperWidth; const p = this.options.snapStepY || this.wrapperHeight; if (this.pages = [], this.wrapperWidth && this.wrapperHeight && this.scrollerWidth && this.scrollerHeight) {
					if (this.options.snap === !0) {
						for (s = e.round(c / 2), o = e.round(p / 2); l > -this.scrollerWidth;) {
							for (this.pages[h] = [], t = 0, n = 0; n > -this.scrollerHeight;) {
								this.pages[h][t] = {
									x: e.max(l, this.maxScrollX), y: e.max(n, this.maxScrollY), width: c, height: p, cx: l - s, cy: n - o,
								}, n -= p, t++;
							} l -= c, h++;
						}
					} else {
						for (r = this.options.snap, t = r.length, i = -1; h < t; h++) {
							(h === 0 || r[h].offsetLeft <= r[h - 1].offsetLeft) && (a = 0, i++), this.pages[a] || (this.pages[a] = []), l = e.max(-r[h].offsetLeft, this.maxScrollX), n = e.max(-r[h].offsetTop, this.maxScrollY), s = l - e.round(r[h].offsetWidth / 2), o = n - e.round(r[h].offsetHeight / 2), this.pages[a][i] = {
								x: l, y: n, width: r[h].offsetWidth, height: r[h].offsetHeight, cx: s, cy: o,
							}, l > this.maxScrollX && a++;
						}
					} this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0), this.options.snapThreshold % 1 === 0 ? (this.snapThresholdX = this.options.snapThreshold, this.snapThresholdY = this.options.snapThreshold) : (this.snapThresholdX = e.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold), this.snapThresholdY = e.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold));
				}
			}), this.on('flick', function () { const t = this.options.snapSpeed || e.max(e.max(e.min(e.abs(this.x - this.startX), 1e3), e.min(e.abs(this.y - this.startY), 1e3)), 300); this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, t); });
		},
		_nearestSnap(t, i) {
			if (!this.pages.length) {
				return {
					x: 0, y: 0, pageX: 0, pageY: 0,
				};
			} let s = 0; let o = this.pages.length; let n = 0; if (e.abs(t - this.absStartX) < this.snapThresholdX && e.abs(i - this.absStartY) < this.snapThresholdY) return this.currentPage; for (t > 0 ? t = 0 : t < this.maxScrollX && (t = this.maxScrollX), i > 0 ? i = 0 : i < this.maxScrollY && (i = this.maxScrollY); s < o; s++) if (t >= this.pages[s][0].cx) { t = this.pages[s][0].x; break; } for (o = this.pages[s].length; n < o; n++) if (i >= this.pages[0][n].cy) { i = this.pages[0][n].y; break; } return s == this.currentPage.pageX && (s += this.directionX, s < 0 ? s = 0 : s >= this.pages.length && (s = this.pages.length - 1), t = this.pages[s][0].x), n == this.currentPage.pageY && (n += this.directionY, n < 0 ? n = 0 : n >= this.pages[0].length && (n = this.pages[0].length - 1), i = this.pages[0][n].y), {
				x: t, y: i, pageX: s, pageY: n,
			};
		},
		goToPage(t, i, s, o) {
			o = o || this.options.bounceEasing, t >= this.pages.length ? t = this.pages.length - 1 : t < 0 && (t = 0), i >= this.pages[t].length ? i = this.pages[t].length - 1 : i < 0 && (i = 0); const n = this.pages[t][i].x; const r = this.pages[t][i].y; s = void 0 === s ? this.options.snapSpeed || e.max(e.max(e.min(e.abs(n - this.x), 1e3), e.min(e.abs(r - this.y), 1e3)), 300) : s, this.currentPage = {
				x: n, y: r, pageX: t, pageY: i,
			}, this.scrollTo(n, r, s, o);
		},
		next(t, i) { let e = this.currentPage.pageX; let s = this.currentPage.pageY; e++, e >= this.pages.length && this.hasVerticalScroll && (e = 0, s++), this.goToPage(e, s, t, i); },
		prev(t, i) { let e = this.currentPage.pageX; let s = this.currentPage.pageY; e--, e < 0 && this.hasVerticalScroll && (e = 0, s--), this.goToPage(e, s, t, i); },
		_initKeys(i) {
			let e; const s = {
				pageUp: 33, pageDown: 34, end: 35, home: 36, left: 37, up: 38, right: 39, down: 40,
			}; if (typeof this.options.keyBindings === 'object') for (e in this.options.keyBindings) typeof this.options.keyBindings[e] === 'string' && (this.options.keyBindings[e] = this.options.keyBindings[e].toUpperCase().charCodeAt(0)); else this.options.keyBindings = {}; for (e in s) this.options.keyBindings[e] = this.options.keyBindings[e] || s[e]; h.addEvent(t, 'keydown', this), this.on('destroy', function () { h.removeEvent(t, 'keydown', this); });
		},
		_key(t) { if (this.enabled) { let i; const s = this.options.snap; let o = s ? this.currentPage.pageX : this.x; let n = s ? this.currentPage.pageY : this.y; const r = h.getTime(); const a = this.keyTime || 0; const l = 0.25; switch (this.options.useTransition && this.isInTransition && (i = this.getComputedPosition(), this._translate(e.round(i.x), e.round(i.y)), this.isInTransition = !1), this.keyAcceleration = r - a < 200 ? e.min(this.keyAcceleration + l, 50) : 0, t.keyCode) { case this.options.keyBindings.pageUp: this.hasHorizontalScroll && !this.hasVerticalScroll ? o += s ? 1 : this.wrapperWidth : n += s ? 1 : this.wrapperHeight; break; case this.options.keyBindings.pageDown: this.hasHorizontalScroll && !this.hasVerticalScroll ? o -= s ? 1 : this.wrapperWidth : n -= s ? 1 : this.wrapperHeight; break; case this.options.keyBindings.end: o = s ? this.pages.length - 1 : this.maxScrollX, n = s ? this.pages[0].length - 1 : this.maxScrollY; break; case this.options.keyBindings.home: o = 0, n = 0; break; case this.options.keyBindings.left: o += s ? -1 : 5 + this.keyAcceleration >> 0; break; case this.options.keyBindings.up: n += s ? 1 : 5 + this.keyAcceleration >> 0; break; case this.options.keyBindings.right: o -= s ? -1 : 5 + this.keyAcceleration >> 0; break; case this.options.keyBindings.down: n -= s ? 1 : 5 + this.keyAcceleration >> 0; break; default: return; } if (s) return void this.goToPage(o, n); o > 0 ? (o = 0, this.keyAcceleration = 0) : o < this.maxScrollX && (o = this.maxScrollX, this.keyAcceleration = 0), n > 0 ? (n = 0, this.keyAcceleration = 0) : n < this.maxScrollY && (n = this.maxScrollY, this.keyAcceleration = 0), this.scrollTo(o, n, 0), this.keyTime = r; } },
		_animate(t, i, e, s) { function o() { let d; let u; let f; let m = h.getTime(); return m >= p ? (n.isAnimating = !1, n._translate(t, i), void (n.resetPosition(n.options.bounceTime) || n._execEvent('scrollEnd'))) : (m = (m - c) / e, f = s(m), d = (t - a) * f + a, u = (i - l) * f + l, n._translate(d, u), void (n.isAnimating && r(o))); } var n = this; var a = this.x; var l = this.y; var c = h.getTime(); var p = c + e; this.isAnimating = !0, o(); },
		handleEvent(t) { switch (t.type) { case 'touchstart': case 'pointerdown': case 'MSPointerDown': case 'mousedown': this._start(t); break; case 'touchmove': case 'pointermove': case 'MSPointerMove': case 'mousemove': this._move(t); break; case 'touchend': case 'pointerup': case 'MSPointerUp': case 'mouseup': case 'touchcancel': case 'pointercancel': case 'MSPointerCancel': case 'mousecancel': this._end(t); break; case 'orientationchange': case 'resize': this._resize(); break; case 'transitionend': case 'webkitTransitionEnd': case 'oTransitionEnd': case 'MSTransitionEnd': this._transitionEnd(t); break; case 'wheel': case 'DOMMouseScroll': case 'mousewheel': this._wheel(t); break; case 'keydown': this._key(t); break; case 'click': this.enabled && !t._constructed && (t.preventDefault(), t.stopPropagation()); } },
	}, n.prototype = {
		handleEvent(t) { switch (t.type) { case 'touchstart': case 'pointerdown': case 'MSPointerDown': case 'mousedown': this._start(t); break; case 'touchmove': case 'pointermove': case 'MSPointerMove': case 'mousemove': this._move(t); break; case 'touchend': case 'pointerup': case 'MSPointerUp': case 'mouseup': case 'touchcancel': case 'pointercancel': case 'MSPointerCancel': case 'mousecancel': this._end(t); } },
		destroy() { this.options.fadeScrollbars && (clearTimeout(this.fadeTimeout), this.fadeTimeout = null), this.options.interactive && (h.removeEvent(this.indicator, 'touchstart', this), h.removeEvent(this.indicator, h.prefixPointerEvent('pointerdown'), this), h.removeEvent(this.indicator, 'mousedown', this), h.removeEvent(t, 'touchmove', this), h.removeEvent(t, h.prefixPointerEvent('pointermove'), this), h.removeEvent(t, 'mousemove', this), h.removeEvent(t, 'touchend', this), h.removeEvent(t, h.prefixPointerEvent('pointerup'), this), h.removeEvent(t, 'mouseup', this)), this.options.defaultScrollbars && this.wrapper.parentNode.removeChild(this.wrapper); },
		_start(i) { const e = i.touches ? i.touches[0] : i; i.preventDefault(), i.stopPropagation(), this.transitionTime(), this.initiated = !0, this.moved = !1, this.lastPointX = e.pageX, this.lastPointY = e.pageY, this.startTime = h.getTime(), this.options.disableTouch || h.addEvent(t, 'touchmove', this), this.options.disablePointer || h.addEvent(t, h.prefixPointerEvent('pointermove'), this), this.options.disableMouse || h.addEvent(t, 'mousemove', this), this.scroller._execEvent('beforeScrollStart'); },
		_move(t) { let i; let e; let s; let o; const n = t.touches ? t.touches[0] : t; h.getTime(); this.moved || this.scroller._execEvent('scrollStart'), this.moved = !0, i = n.pageX - this.lastPointX, this.lastPointX = n.pageX, e = n.pageY - this.lastPointY, this.lastPointY = n.pageY, s = this.x + i, o = this.y + e, this._pos(s, o), t.preventDefault(), t.stopPropagation(); },
		_end(i) { if (this.initiated) { if (this.initiated = !1, i.preventDefault(), i.stopPropagation(), h.removeEvent(t, 'touchmove', this), h.removeEvent(t, h.prefixPointerEvent('pointermove'), this), h.removeEvent(t, 'mousemove', this), this.scroller.options.snap) { const s = this.scroller._nearestSnap(this.scroller.x, this.scroller.y); const o = this.options.snapSpeed || e.max(e.max(e.min(e.abs(this.scroller.x - s.x), 1e3), e.min(e.abs(this.scroller.y - s.y), 1e3)), 300); this.scroller.x == s.x && this.scroller.y == s.y || (this.scroller.directionX = 0, this.scroller.directionY = 0, this.scroller.currentPage = s, this.scroller.scrollTo(s.x, s.y, o, this.scroller.options.bounceEasing)); } this.moved && this.scroller._execEvent('scrollEnd'); } },
		transitionTime(t) { t = t || 0; const i = h.style.transitionDuration; if (i && (this.indicatorStyle[i] = `${t}ms`, !t && h.isBadAndroid)) { this.indicatorStyle[i] = '0.0001ms'; const e = this; r(() => { e.indicatorStyle[i] === '0.0001ms' && (e.indicatorStyle[i] = '0s'); }); } },
		transitionTimingFunction(t) { this.indicatorStyle[h.style.transitionTimingFunction] = t; },
		refresh() { this.transitionTime(), this.options.listenX && !this.options.listenY ? this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none' : this.options.listenY && !this.options.listenX ? this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none' : this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none', this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll ? (h.addClass(this.wrapper, 'iScrollBothScrollbars'), h.removeClass(this.wrapper, 'iScrollLoneScrollbar'), this.options.defaultScrollbars && this.options.customStyle && (this.options.listenX ? this.wrapper.style.right = '8px' : this.wrapper.style.bottom = '8px')) : (h.removeClass(this.wrapper, 'iScrollBothScrollbars'), h.addClass(this.wrapper, 'iScrollLoneScrollbar'), this.options.defaultScrollbars && this.options.customStyle && (this.options.listenX ? this.wrapper.style.right = '2px' : this.wrapper.style.bottom = '2px')); this.wrapper.offsetHeight; this.options.listenX && (this.wrapperWidth = this.wrapper.clientWidth, this.options.resize ? (this.indicatorWidth = e.max(e.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8), this.indicatorStyle.width = `${this.indicatorWidth}px`) : this.indicatorWidth = this.indicator.clientWidth, this.maxPosX = this.wrapperWidth - this.indicatorWidth, this.options.shrink == 'clip' ? (this.minBoundaryX = -this.indicatorWidth + 8, this.maxBoundaryX = this.wrapperWidth - 8) : (this.minBoundaryX = 0, this.maxBoundaryX = this.maxPosX), this.sizeRatioX = this.options.speedRatioX || this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX), this.options.listenY && (this.wrapperHeight = this.wrapper.clientHeight, this.options.resize ? (this.indicatorHeight = e.max(e.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8), this.indicatorStyle.height = `${this.indicatorHeight}px`) : this.indicatorHeight = this.indicator.clientHeight, this.maxPosY = this.wrapperHeight - this.indicatorHeight, this.options.shrink == 'clip' ? (this.minBoundaryY = -this.indicatorHeight + 8, this.maxBoundaryY = this.wrapperHeight - 8) : (this.minBoundaryY = 0, this.maxBoundaryY = this.maxPosY), this.maxPosY = this.wrapperHeight - this.indicatorHeight, this.sizeRatioY = this.options.speedRatioY || this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY), this.updatePosition(); },
		updatePosition() {
			let t = this.options.listenX && e.round(this.sizeRatioX * this.scroller.x) || 0; let i = this.options.listenY && e.round(this.sizeRatioY * this.scroller.y) || 0; this.options.ignoreBoundaries || (t < this.minBoundaryX ? (this.options.shrink == 'scale' && (this.width = e.max(this.indicatorWidth + t, 8), this.indicatorStyle.width = `${this.width}px`), t = this.minBoundaryX) : t > this.maxBoundaryX ? this.options.shrink == 'scale' ? (this.width = e.max(this.indicatorWidth - (t - this.maxPosX), 8), this.indicatorStyle.width = `${this.width}px`, t = this.maxPosX + this.indicatorWidth - this.width) : t = this.maxBoundaryX : this.options.shrink == 'scale' && this.width != this.indicatorWidth && (this.width = this.indicatorWidth, this.indicatorStyle.width = `${this.width}px`), i < this.minBoundaryY ? (this.options.shrink == 'scale' && (this.height = e.max(this.indicatorHeight + 3 * i, 8), this.indicatorStyle.height = `${this.height}px`), i = this.minBoundaryY) : i > this.maxBoundaryY ? this.options.shrink == 'scale' ? (this.height = e.max(this.indicatorHeight - 3 * (i - this.maxPosY), 8),
			this.indicatorStyle.height = `${this.height}px`, i = this.maxPosY + this.indicatorHeight - this.height) : i = this.maxBoundaryY : this.options.shrink == 'scale' && this.height != this.indicatorHeight && (this.height = this.indicatorHeight, this.indicatorStyle.height = `${this.height}px`)), this.x = t, this.y = i, this.scroller.options.useTransform ? this.indicatorStyle[h.style.transform] = `translate(${t}px,${i}px)${this.scroller.translateZ}` : (this.indicatorStyle.left = `${t}px`, this.indicatorStyle.top = `${i}px`);
		},
		_pos(t, i) { t < 0 ? t = 0 : t > this.maxPosX && (t = this.maxPosX), i < 0 ? i = 0 : i > this.maxPosY && (i = this.maxPosY), t = this.options.listenX ? e.round(t / this.sizeRatioX) : this.scroller.x, i = this.options.listenY ? e.round(i / this.sizeRatioY) : this.scroller.y, this.scroller.scrollTo(t, i); },
		fade(t, i) { if (!i || this.visible) { clearTimeout(this.fadeTimeout), this.fadeTimeout = null; const e = t ? 250 : 500; const s = t ? 0 : 300; t = t ? '1' : '0', this.wrapperStyle[h.style.transitionDuration] = `${e}ms`, this.fadeTimeout = setTimeout(function (t) { this.wrapperStyle.opacity = t, this.visible = +t; }.bind(this, t), s); } },
	}, s.utils = h, typeof module !== 'undefined' && module.exports ? module.exports = s : typeof define === 'function' && define.amd ? define(() => s) : t.IScroll = s;
}(window, document, Math)), /*!
 * fullPage ScrollOverflow
 * https://github.com/alvarotrigo/fullPage.js
 * @license MIT licensed
 *
 * Copyright (C) 2015 alvarotrigo.com - A project by Alvaro Trigo
 */
(function (t, i) {
	const e = 'active'; const s = `.${e}`; const o = 'fp-section'; const n = `.${o}`; const r = n + s; const h = 'fp-slide'; const a = `.${h}`; const l = a + s; const c = 'fp-slides'; const p = `.${c}`; const d = 'fp-scrollable'; const u = `.${d}`; typeof IScroll !== 'undefined' && (IScroll.prototype.wheelOn = function () { this.wrapper.addEventListener('wheel', this), this.wrapper.addEventListener('mousewheel', this), this.wrapper.addEventListener('DOMMouseScroll', this); }, IScroll.prototype.wheelOff = function () { this.wrapper.removeEventListener('wheel', this), this.wrapper.removeEventListener('mousewheel', this), this.wrapper.removeEventListener('DOMMouseScroll', this); }), t.iscrollHandler = {
		refreshId: null,
		iScrollInstances: [],
		toggleWheel(t) { const e = i(r).find(u); e.each(function () { const e = i(this).data('iscrollInstance'); typeof e !== 'undefined' && e && (t ? e.wheelOn() : e.wheelOff()); }); },
		onLeave() { iscrollHandler.toggleWheel(!1); },
		beforeLeave() { iscrollHandler.onLeave(); },
		afterLoad() { iscrollHandler.toggleWheel(!0); },
		create(t, e, s) { const o = t.find(u); o.height(e), o.each(function () { const t = i(this); let e = t.data('iscrollInstance'); e && i.each(iscrollHandler.iScrollInstances, function () { i(this).destroy(); }), e = new IScroll(t.get(0), s), e.on('scrollEnd', function () { this.fp_isAtTop = this.y > -30, this.fp_isAtEnd = this.y - this.maxScrollY < 30; }), iscrollHandler.iScrollInstances.push(e), e.wheelOff(), t.data('iscrollInstance', e); }); },
		isScrolled(t, i) { const e = i.data('iscrollInstance'); return !e || (t === 'top' ? e.y >= 0 && !i.scrollTop() : t === 'bottom' ? 0 - e.y + i.scrollTop() + 1 + i.innerHeight() >= i[0].scrollHeight : void 0); },
		scrollable(t) { return t.find(p).length ? t.find(l).find(u) : t.find(u); },
		scrollHeight(t) { return t.find(u).children().first().get(0).scrollHeight; },
		remove(t) {
			const i = t.find(u); if (i.length) { const e = i.data('iscrollInstance'); e && e.destroy(), i.data('iscrollInstance', null); }t.find(u).children().first().children()
				.first()
				.unwrap()
				.unwrap();
		},
		update(t, e) { clearTimeout(iscrollHandler.refreshId), iscrollHandler.refreshId = setTimeout(() => { i.each(iscrollHandler.iScrollInstances, function () { i(this).get(0).refresh(); }); }, 150), t.find(u).css('height', `${e}px`).parent().css('height', `${e}px`); },
		wrapContent() { return `<div class="${d}"><div class="fp-scroller"></div></div>`; },
	};
}(window, jQuery)), (function (t, i, e) {
	$.fn.fp_scrolloverflow = (function () {
		function e() { function e() { $('body').hasClass(g) ? n() : o(s), $.fn.fullpage.shared.afterRenderActions(); } function s(i) { if (!i.hasClass('fp-noscroll')) { i.css('overflow', 'hidden'); let e; const s = r.options.scrollOverflowHandler; const o = s.wrapContent(); const n = i.closest(a); const h = s.scrollable(i); h.length ? e = s.scrollHeight(i) : (e = i.get(0).scrollHeight, r.options.verticalCentered && (e = i.find(v).get(0).scrollHeight)); const l = $(t).height() - parseInt(n.css('padding-bottom')) - parseInt(n.css('padding-top')); e > l ? h.length ? s.update(i, l) : (r.options.verticalCentered ? i.find(v).wrapInner(o) : i.wrapInner(o), s.create(i, l, r.iscrollOptions)) : s.remove(i), i.css('overflow', ''); } } function o(t) { $(a).each(function () { const i = $(this).find(p); i.length ? i.each(function () { t($(this)); }) : t($(this)); }); } function n() { const t = r.options.scrollOverflowHandler; o((i) => { i.closest(a).hasClass(y) && t.remove(i); }); } var r = this; r.options = null, r.init = function (s, o) { return r.options = s, r.iscrollOptions = o, i.readyState === 'complete' && e(), $(t).on('load', e), r; }, r.createScrollBarForAll = e; } const s = 'fp-scrollable'; const o = `.${s}`; const n = 'active'; const r = `.${n}`; const h = 'fp-section'; var a = `.${h}`; const l = a + r; const c = 'fp-slide'; var p = `.${c}`; const d = p + r; const u = 'fp-slides'; const f = `.${u}`; const m = 'fp-tableCell'; var v = `.${m}`; var g = 'fp-responsive'; var y = 'fp-auto-height-responsive'; IScroll.prototype.wheelOn = function () { this.wrapper.addEventListener('wheel', this), this.wrapper.addEventListener('mousewheel', this), this.wrapper.addEventListener('DOMMouseScroll', this); }, IScroll.prototype.wheelOff = function () { this.wrapper.removeEventListener('wheel', this), this.wrapper.removeEventListener('mousewheel', this), this.wrapper.removeEventListener('DOMMouseScroll', this); }; var S = {
			refreshId: null,
			iScrollInstances: [],
			iscrollOptions: {
				scrollbars: !0, mouseWheel: !0, hideScrollbars: !1, fadeScrollbars: !1, disableMouse: !0, interactiveScrollbars: !0,
			},
			init(i) { const s = 'ontouchstart' in t || navigator.msMaxTouchPoints > 0 || navigator.maxTouchPoints; return S.iscrollOptions.click = s, S.iscrollOptions = $.extend(S.iscrollOptions, i.scrollOverflowOptions), (new e()).init(i, S.iscrollOptions); },
			toggleWheel(t) { const i = $(l).find(o); i.each(function () { const i = $(this).data('iscrollInstance'); typeof i !== 'undefined' && i && (t ? i.wheelOn() : i.wheelOff()); }); },
			onLeave() { S.toggleWheel(!1); },
			beforeLeave() { S.onLeave(); },
			afterLoad() { S.toggleWheel(!0); },
			create(t, i, e) { const s = t.find(o); s.height(i), s.each(function () { const t = $(this); let i = t.data('iscrollInstance'); i && $.each(S.iScrollInstances, function () { $(this).destroy(); }), i = new IScroll(t.get(0), e), S.iScrollInstances.push(i), i.wheelOff(), t.data('iscrollInstance', i); }); },
			isScrolled(t, i) { const e = i.data('iscrollInstance'); return !e || (t === 'top' ? e.y >= 0 && !i.scrollTop() : t === 'bottom' ? 0 - e.y + i.scrollTop() + 1 + i.innerHeight() >= i[0].scrollHeight : void 0); },
			scrollable(t) { return t.find(f).length ? t.find(d).find(o) : t.find(o); },
			scrollHeight(t) { return t.find(o).children().first().get(0).scrollHeight; },
			remove(t) {
				const i = t.find(o); if (i.length) { const e = i.data('iscrollInstance'); e.destroy(), i.data('iscrollInstance', null); }t.find(o).children().first().children()
					.first()
					.unwrap()
					.unwrap();
			},
			update(t, i) { clearTimeout(S.refreshId), S.refreshId = setTimeout(() => { $.each(S.iScrollInstances, function () { $(this).get(0).refresh(); }); }, 150), t.find(o).css('height', `${i}px`).parent().css('height', `${i}px`); },
			wrapContent() { return `<div class="${s}"><div class="fp-scroller"></div></div>`; },
		}; return { iscrollHandler: S };
	}());
}(window, jQuery));
// # sourceMappingURL=scrolloverflow.min.js.map
